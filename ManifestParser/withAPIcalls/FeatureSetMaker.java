package ManifestParser.withAPIcalls;

import ManifestParser.util.DatasetFolders;
import net.dongliu.apk.parser.ApkFile;
import net.dongliu.apk.parser.bean.ApkMeta;
import org.jdom2.Attribute;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.input.SAXBuilder;
import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.ReferenceType;
import org.jf.dexlib2.dexbacked.DexBackedDexFile;
import org.jf.dexlib2.iface.ClassDef;
import org.jf.dexlib2.iface.Method;
import org.jf.dexlib2.iface.MethodImplementation;
import org.jf.dexlib2.iface.instruction.Instruction;
import org.jf.dexlib2.iface.instruction.ReferenceInstruction;
import org.jf.dexlib2.iface.reference.MethodReference;

import java.io.*;
import java.util.*;

import static ManifestParser.util.utilities.getFiles;
import static ManifestParser.util.utilities.getManifest;

public class FeatureSetMaker {


    public static void main(String[] args)
    {
        int errorCounter = 0, totalCounter = 0;

        manifestParser.path = "ManifestParser/withAPIcalls/output/Final_D1__A__";
        String[] goodware = DatasetFolders.GoodwareD1;
        String[] malware =  DatasetFolders.MalwareD1;

        for(String folder : goodware) {
            System.out.println(folder);
            String[] Files = getFiles(folder);
            System.out.println("Number of Files" + Files.length);
            for (String fileName : Files) {
                try {
                    totalCounter += 1;
                    System.out.println(fileName);
                    apkDetails(folder + "/" + fileName);
                } catch (Exception e) {
                    errorCounter += 1;
                    System.out.println("Error" + errorCounter + " - " + totalCounter);
                }
            }
        }

        for(String folder : malware) {
            System.out.println(folder);
            String[] Files = getFiles(folder);
            System.out.println("Number of Files" + Files.length);
            for (String fileName : Files) {
                try {
                    System.out.println(fileName);
                    totalCounter += 1;
                    apkDetails(folder + "/" + fileName);
                } catch (Exception e) {
                    errorCounter += 1;
                    System.out.println("Error" + errorCounter + " - " + totalCounter);
                }
            }

        }
        System.out.println("Total Counter :" + totalCounter + "/" + errorCounter);
        manifestParser.printHM();
    }

    static void apkDetails(String filePath){
        try (ApkFile apkFile = new ApkFile(new File(filePath))) {
            ApkMeta apkMeta = apkFile.getApkMeta();
            //  System.out.println(apkMeta.getMinSdkVersion());
            manifestParser mp = new manifestParser(getManifest(filePath));
            //mp.SAXParser();
            //mp.getPermissionFromApkParser(apkMeta);
            mp.getApiCalls(filePath);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}

class manifestParser{
    static String xmlString;
    static HashMap<String, Integer> hm;


    manifestParser(String xmlString){
        manifestParser.xmlString = xmlString;
        if (hm == null)
            hm = new HashMap<>();
    }

    public void SAXParser(){
        try {
            SAXBuilder sax = new SAXBuilder();
            InputStream targetStream = new ByteArrayInputStream(xmlString.getBytes());
            Document doc = sax.build(targetStream);
            Element rootNode = doc.getRootElement();
            List<String> tags = Arrays.asList("uses-permission"); //"permission", "uses-feature", "service", "receiver", "uses-library", "provider", "action");

            for(String tag : tags){
                parseTag(rootNode, tag);
            }

        } catch (IOException | JDOMException e) {
            e.printStackTrace();
        }
    }

    void parseTag(Element rootNode, String tag){
        List<Element> usesPermissions = rootNode.getChildren(tag);
        tag = tag + " :";
        tag = "";
        for (Element usesPermission : usesPermissions) {
            for(Attribute attri : usesPermission.getAttributes()){
                String key = attri.getValue();

                if(key.contains(" ") || !key.contains("."))
                    continue;
                key = key.toUpperCase(Locale.ROOT);
                try {
                    hm.put(tag+key, hm.get(tag+key) + 1);
                } catch (Exception e) {
                    hm.put(tag+key, 1);
                }

            }
        }
    }

    void getPermissionFromApkParser(ApkMeta apkMeta){
        for(String perm : apkMeta.getUsesPermissions()){
            String key = perm;
            String tag = "";
            if(key.contains(" ") || !key.contains("."))
                continue;
            key = key.toUpperCase(Locale.ROOT);
            try {
                hm.put(tag+key, hm.get(tag+key) + 1);
            } catch (Exception e) {
                hm.put(tag+key, 1);
            }

        }
    }





    public static void printHM(){
        HashMap<String, Integer> hm1 = sortByValue(hm);
        System.out.println(hm1.size());
        WriteToFile(hm1);

    }

    public static HashMap<String, Integer> sortByValue(HashMap<String, Integer> hm)
    {
        // Create a list from elements of HashMap
        List<Map.Entry<String, Integer> > list =
                new LinkedList<Map.Entry<String, Integer> >(hm.entrySet());

        // Sort the list
        Collections.sort(list, new Comparator<Map.Entry<String, Integer> >() {
            public int compare(Map.Entry<String, Integer> o1,
                               Map.Entry<String, Integer> o2)
            {
                return (o1.getValue()).compareTo(o2.getValue());
            }
        });

        // put data from sorted list to hashmap
        HashMap<String, Integer> temp = new LinkedHashMap<String, Integer>();
        for (Map.Entry<String, Integer> aa : list) {
            temp.put(aa.getKey(), aa.getValue());
        }
        return temp;
    }
    public static String path = "ManifestParser/PermissionsOnly/output/Error Occured";
    static void WriteToFile(HashMap<String, Integer> hm1){
        // new file object

        File file = new File(path+java.time.LocalDateTime.now()+".txt");
        BufferedWriter bf = null;

        try {
            // create new BufferedWriter for the output file
            bf = new BufferedWriter(new FileWriter(file));
            for (Map.Entry<String, Integer> entry :
                    hm1.entrySet()) {
                if(entry.getValue() <= 200 || entry.getKey().length() < 4)
                    continue;
                bf.write( entry.getKey() + ":" + entry.getValue());
                // new line
                bf.newLine();
            }

            bf.flush();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        finally {

            try {
                // always close the writer
                bf.close();
            }
            catch (Exception ignored) {
            }
        }
    }


    //API Extraction Section
    void getApiCalls(String location){

        DexBackedDexFile dexFile = null ;
        try{
            dexFile = DexFileFactory.loadDexFile(location
                    , Opcodes.getDefault());

        }catch (IOException ioe){
            ioe.printStackTrace();
        }
        if (dexFile != null){
            printMethodInvocations(dexFile);
        }else
        {
            System.out.println("getApiCalls"  + "onCreate: dex file is null");
        }

    }

    String APIcallCleaner(String s){
        String s1 = s.substring(s.indexOf("->") + 2);
        s1.trim();
        s = s.replace("(", "\n");

        s = s.replaceAll(".+>", "");
        s = s.split("\n")[0];
        return s;
    }


    //Taken From https://gist.github.com/JesusFreke/396458abb2145224e13773ee649f57c5
    public void printMethodInvocations(DexBackedDexFile dexFile) {
        for (ClassDef classDef: dexFile.getClasses()) {
            for (Method methodDef: classDef.getMethods()) {
                MethodImplementation methodImpl = methodDef.getImplementation();

                if (methodImpl != null) {
                    for (Instruction instruction: methodImpl.getInstructions()) {
                        if (instruction instanceof ReferenceInstruction) {
                            if (((ReferenceInstruction)instruction).getReferenceType() == ReferenceType.METHOD) {
                                MethodReference methodReference =
                                        (MethodReference) ((ReferenceInstruction)instruction).getReference();
                                String apiCall =  APIcallCleaner(String.valueOf(methodReference));
                                boolean isValid = apiCall.matches("[a-zA-Z]+");
                                if(!isValid)
                                    continue;
                                String tag = "apiCall";
                                String apiCallClass = String.valueOf(methodReference).split("/")[0];
                                tag = " :\t" + String.valueOf(methodReference).split("/")[0];
                                tag = "";
                                if(apiCall.length() > 2 && (apiCallClass.equals("Landroid") || apiCallClass.equals("Ljava") || apiCallClass.equals("Lorg"))) {
                                    //Add here
                                    String key = apiCall;
                                    key = key.toUpperCase(Locale.ROOT);
                                    try {
                                        hm.put(tag+key, hm.get(tag+key) + 1);
                                    } catch (Exception e) {
                                        hm.put(tag+key, 1);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }


}

